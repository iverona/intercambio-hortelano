# Technical Documentation: Portal de Intercambio Hortelano

Welcome to the technical documentation for the Portal de Intercambio Hortelano application. This document is intended for new developers joining the project and aims to provide a comprehensive overview of the architecture, code structure, and core features.

## 1. Overview

This application is a web platform that connects local gardeners and food producers, allowing them to exchange, sell, or simply share their products with their community. It includes features like location-based listings, a real-time chat system for coordination, and a gamification system to encourage participation.

## 2. Technology Stack

This section details the primary technologies and frameworks used to build the application.

### Frontend

*   **Framework:** Next.js (v15) with React (v19)
*   **Language:** TypeScript
*   **Styling:** Tailwind CSS (v4)
*   **UI Components:** shadcn/ui (built on Radix UI)
*   **Internationalization (i18n):** next-international
*   **State Management:** React Context API
*   **Client-side Cache:** SWR (via Next.js App Router)
*   **Icons:** Lucide React
*   **Notifications (Toasts):** Sonner
*   **Firebase SDK:** `firebase` (for client-side interaction)

### Backend

*   **Platform:** Firebase
*   **Serverless Functions:** Cloud Functions for Firebase
*   **Language:** TypeScript (running on Node.js v22)
*   **Database:** Firestore (NoSQL)
*   **Authentication:** Firebase Authentication
*   **Admin SDK:** `firebase-admin` (for server-side operations)

## 3. Codebase Structure

The repository is organized into two main directories: `frontend` and `functions`.

### `frontend/`

This directory contains the entire Next.js web application.

*   `src/app/`: The core of the application, using the Next.js App Router.
    *   `[locale]/`: This is a dynamic route segment that captures the current language (e.g., `en` or `es`). All user-facing pages are nested inside this directory to ensure they are internationalized.
*   `src/components/`: Contains reusable React components.
    *   `ui/`: Components generated by the `shadcn/ui` CLI. These should generally not be modified directly.
    *   `shared/`: Custom, application-specific components built from the `ui` components (e.g., `ChatList`, `OfferModal`).
*   `src/lib/`: Utility functions, library configurations, and core logic.
    *   `firebase.ts`: Initializes and exports the client-side Firebase app instance.
    *   `notifications.ts`: Logic for creating and managing notification documents in Firestore.
*   `src/context/`: Global state management using React Context.
    *   `AuthContext.tsx`: Manages and provides the current user's authentication state.
    *   `NotificationContext.tsx`: Listens for real-time notifications from Firestore and displays them.
*   `src/locales/`: Contains all files related to the internationalization setup.
    *   `en.ts` & `es.ts`: These files export objects containing the key-value pairs for English and Spanish translations, respectively.
    *   `provider.tsx`: A client-side component that wraps the application and provides the i18n context.
    *   `server.ts`: Contains server-side utilities for i18n, such as getting the current locale.
*   `src/middleware.ts`: This file is responsible for handling internationalized routing. It inspects incoming requests and rewrites the URL to the appropriate locale path based on the user's browser settings or cookies.

### `functions/`

This directory contains the backend logic deployed as Firebase Cloud Functions.

*   `src/index.ts`: The main entry point for all cloud functions.

## 4. Core Features & Components

This section dives into the implementation details of the application's key features.

### Authentication Flow

Authentication is managed by **Firebase Authentication**. Users can sign up and sign in via email/password or Google Sign-In.

1.  **Firebase Initialization:** The client-side Firebase app is initialized in `frontend/src/lib/firebase.ts`. This configuration is used by all other Firebase services on the frontend.
2.  **State Management:** The `frontend/src/context/AuthContext.tsx` file is the heart of the frontend authentication system.
    *   It creates a React Context (`AuthContext`) to provide the user's authentication state to all components.
    *   The `AuthProvider` component wraps the entire application in `frontend/src/app/layout.tsx`.
    *   It uses the `onAuthStateChanged` listener from the Firebase SDK. This listener fires whenever a user logs in or out, providing the `User` object.
3.  **Accessing User Data:** Any component that needs to know about the current user can use the `useAuth()` custom hook. This hook returns the current `user` object and a `loading` state.

    ```tsx
    // Example usage in a component
    import { useAuth } from '@/context/AuthContext';

    function ProfileButton() {
      const { user, loading } = useAuth();

      if (loading) return <div>Loading...</div>;
      if (!user) return <a href="/login">Log In</a>;

      return <div>Welcome, {user.displayName}</div>;
    }
    ```
4.  **Protected Routes:** The application uses this context to implement protected routes. Layout files or page components check for the presence of a `user` object and redirect to the login page if it's missing.

### Internationalization (i18n)

The application is fully internationalized to support both English and Spanish, with a structure that allows for easy addition of new languages. This is managed by the `next-international` library.

1.  **Directory Structure & Routing:**
    *   All user-facing pages are located within the `frontend/src/app/[locale]/` directory. The `[locale]` segment is dynamic and captures the current language from the URL (e.g., `/en/profile`, `/es/profile`).
    *   This structure ensures that every route is explicitly associated with a language.

2.  **Middleware for Language Detection:**
    *   The `frontend/src/middleware.ts` file uses `createI18nMiddleware` from `next-international`.
    *   This middleware automatically detects the user's preferred language from the `Accept-Language` header of incoming requests.
    *   It then rewrites the URL to the appropriate locale path (e.g., `/` becomes `/en` or `/es`). This provides seamless, automatic language detection for first-time visitors.

3.  **Translation Files:**
    *   All translated strings are stored in `frontend/src/locales/en.ts` and `frontend/src/locales/es.ts`. These files export a default object where keys represent a concept (e.g., `header.profile`) and values are the translated strings.

4.  **Using Translations in Components:**
    *   To use translations in a client component, the `useI18n` hook is used.
    *   The component must be a client component (`'use client'`).
    *   The hook provides a `t` function that takes a translation key and returns the appropriate string for the current locale.

    ```tsx
    // Example usage in a component
    'use client';
    import { useI18n } from '@/locales/client';

    export default function Greeting() {
      const t = useI18n();
      return <h1>{t('home.welcome_message')}</h1>;
    }
    ```

5.  **Layout Structure for Hydration:**
    *   A common issue with i18n in Next.js is React Hydration Mismatch errors. This was solved by using a two-layout system:
        *   `frontend/src/app/layout.tsx`: This is the absolute root layout. It is kept minimal and only contains the `<html>` and `<body>` tags. It does **not** contain any providers or UI that might differ between server and client renders.
        *   `frontend/src/app/[locale]/layout.tsx`: This is the main application layout. It contains the `I18nProviderClient`, `AuthProvider`, the site header, footer, and all other global UI elements. Because it's inside the `[locale]` segment, it has access to the correct language context from the start.

### Firestore Data Models

Firestore is the primary database for the application. Data is organized into several top-level collections.

#### `users`
Stores public information about each user. The document ID is the same as the Firebase Auth `uid`.

*   `userId: string` - The user's unique ID.
*   `displayName: string` - The user's public name.
*   `email: string` - The user's email address.
*   `location: GeoPoint` - The user's general location for distance calculations.
*   `bio: string` - A short user biography.
*   `reputation: object` - Calculated by the `updateUserReputation` function.
    *   `averageRating: number` - The user's average review score (0-5).
    *   `totalReviews: number` - The total number of reviews the user has received.
*   `points: number` - The user's gamification points.
*   `level: string` - The user's current level (e.g., "Seed", "Sprout").

#### `listings`
Contains all items offered by users for sale or exchange.

*   `listingId: string` - The unique ID for the listing.
*   `title: string` - The title of the listing.
*   `description: string` - A detailed description of the product.
*   `category: string` - The product category (e.g., "Vegetables").
*   `iconId: string` - An identifier for the icon representing the product.
*   `isForExchange: boolean` - True if the item is available for trade.
*   `price: number` - The monetary price of the item.
*   `location: GeoPoint` - The location of the product, for proximity searches.
*   `producerId: string` - A reference to the `userId` of the user who created the listing.

#### `exchanges`
Tracks the lifecycle of a transaction between two users.

*   `exchangeId: string` - The unique ID for the exchange.
*   `listingId: string` - Reference to the associated listing.
*   `producerId: string` - The user who owns the listing.
*   `consumerId: string` - The user who initiated the exchange.
*   `status: string` - The current state of the exchange (e.g., "proposed", "accepted", "completed").
*   `chatId: string` - A reference to the associated document in the `chats` collection.
*   `reviews: map` - A map where keys are `userIds` and values are review objects.
    *   `rating: number`
    *   `comment: string`
    *   `reviewedUserId: string`

#### `chats`
Stores metadata for a chat thread between two or more users.

*   `participants: array<string>` - An array of `userIds` who are in the chat.
*   `listingTitle: string` - The title of the listing the chat is about.
*   `lastMessage: object` - A copy of the most recent message for quick display in chat lists.
    *   `text: string`
    *   `senderId: string`
    *   `createdAt: Timestamp`
*   **Sub-collection:** `messages` - Each document in this sub-collection represents a single message.
    *   `text: string`
    *   `senderId: string`
    *   `createdAt: Timestamp`

#### `notifications`
A collection for storing real-time notifications for users.

*   `recipientId: string` - The `userId` who should receive the notification.
*   `type: string` - The type of notification (e.g., "NEW_OFFER", "MESSAGE_RECEIVED").
*   `message: string` - The content of the notification.
*   `isRead: boolean` - Flag to indicate if the user has seen the notification.
*   `entityId: string` - The ID of the related item (e.g., the `exchangeId` or `chatId`).
*   `createdAt: Timestamp`

### UI Components

The user interface is built using **shadcn/ui**, which is a collection of reusable components built on top of Radix UI and styled with Tailwind CSS. This provides a consistent and accessible foundation for the UI.

*   **`frontend/src/components/ui/`**: This directory contains the base components installed directly from the `shadcn/ui` library (e.g., `Button`, `Card`, `Dialog`). **These files should not be modified directly.** If a change is needed, it's better to create a new component in `shared/` that wraps and extends the `ui` component.

*   **`frontend/src/components/shared/`**: This directory contains custom components that are specific to this application. They are built by composing components from the `ui/` directory. Examples include:
    *   `ChatList.tsx`: Renders the list of a user's ongoing chats.
    *   `OfferModal.tsx`: The dialog for making an offer on a listing.
    *   `ListingCard.tsx`: The card component used to display a product in a feed.

When building new UI, developers should first look for an appropriate component in `shadcn/ui`. If the required functionality is more complex, they should create a new component in the `shared/` directory.

### Real-time Notifications System

The application features a real-time notification system to alert users of important events. The entire system is orchestrated on the frontend using Firestore and React Context.

1.  **Creating Notifications:** When a significant event occurs (e.g., a user makes an offer on a listing), the client-side code calls a helper function from `frontend/src/lib/notifications.ts`. This function creates a new document in the `notifications` collection in Firestore.

2.  **Listening for Notifications:** The `frontend/src/context/NotificationContext.tsx` is responsible for listening for new notifications.
    *   It's wrapped around the application layout, so it's always active.
    *   It uses the `useAuth()` hook to get the current user's ID.
    *   It sets up a Firestore `onSnapshot` listener on the `notifications` collection, querying for documents where the `recipientId` matches the current user's ID and `isRead` is `false`.

3.  **Displaying Notifications:**
    *   When the listener detects a new notification document, it uses the **Sonner** library (`import { toast } from 'sonner'`) to display a toast message on the user's screen.
    *   The content of the toast is formatted based on the notification's `type` and `message` fields.
    *   After displaying the toast, the system should ideally mark the notification document as `isRead: true` to prevent it from being shown again.

### Real-time Chat System

The chat system allows users to communicate directly about listings and exchanges. Like the notification system, it is built on Firestore's real-time capabilities.

1.  **Data Model:** The chat is built around the `chats` collection and a `messages` sub-collection.
    *   A single document in `/chats/{chatId}` stores the metadata for a conversation, including the participants.
    *   The actual messages are stored in a sub-collection at `/chats/{chatId}/messages`. This is a highly scalable pattern in Firestore.

2.  **Initiating a Chat:**
    *   A new chat is created when a user makes an initial inquiry on a product from the `frontend/src/app/product/[id]/page.tsx` page.
    *   This action creates a new document in the `chats` collection and a corresponding `exchange` document that links to the chat via a `chatId`.

3.  **Sending & Receiving Messages:**
    *   The main chat interface is located at `frontend/src/app/exchanges/details/[exchangeId]/page.tsx`.
    *   This page sets up an `onSnapshot` listener on the `messages` sub-collection for the relevant chat.
    *   When a new message document is added to the sub-collection, the listener fires, and the UI is updated to display the new message.
    *   When a user sends a message, a new document is added to the `messages` sub-collection, and the `lastMessage` field on the parent `chat` document is also updated to provide a preview on chat list views.

### Gamification & Reputation System (Cloud Functions)

The application's gamification and reputation logic is handled by serverless **Firebase Cloud Functions**. This ensures that reputation calculations are performed securely and consistently. The code for these functions is in `functions/src/index.ts`.

#### `updateUserReputation`
*   **Trigger:** Firestore `onDocumentUpdated` on the `exchanges/{exchangeId}` path.
*   **Purpose:** To automatically recalculate a user's reputation score, points, and level whenever a review is submitted.
*   **Logic:**
    1.  The function detects when the `reviews` map in an exchange document is updated.
    2.  It identifies the user who was reviewed.
    3.  It queries all of that user's completed exchanges to calculate a new `averageRating` and `totalReviews`.
    4.  It awards points for the new review (base points + a bonus for high ratings).
    5.  It calculates the user's new `level` based on their total points.
    6.  Finally, it updates the user's document in the `users` collection with the new reputation data.

#### `initializeUserReputation`
*   **Trigger:** Firestore `onDocumentUpdated` on the `users/{userId}` path.
*   **Purpose:** To ensure every new user has a default reputation object.
*   **Logic:**
    1.  The function checks if a user document is missing the `reputation`, `points`, or `level` fields.
    2.  If they are missing, it updates the document to set the default values (e.g., 0 points, "Seed" level, 0 reviews). This prevents errors in the frontend from trying to read non-existent properties.

## 5. Getting Started

This section provides the basic instructions to get the project running on a local machine for development.

### Prerequisites

*   Node.js (v22 or later)
*   Firebase CLI (`npm install -g firebase-tools`)
*   A Firebase project set up on the [Firebase Console](https://console.firebase.google.com/).

### 1. Clone the Repository

```bash
git clone <repository-url>
cd <repository-directory>
```

### 2. Configure Firebase

1.  Log in to the Firebase CLI:
    ```bash
    firebase login
    ```
2.  Associate the local project with your Firebase project:
    ```bash
    firebase use --add
    ```
    Select your project from the list. This will create a `.firebaserc` file.

3.  **Important:** You will need to set up a Firebase Web App in your project's settings. Once created, copy the `firebaseConfig` object and place it inside `frontend/src/lib/firebase.ts`. This is a critical step for the frontend to communicate with your Firebase project.

### 3. Install Dependencies

The project has two separate `package.json` files. You need to install dependencies for both.

*   **Frontend:**
    ```bash
    cd frontend
    npm install
    ```

*   **Backend (Cloud Functions):**
    ```bash
    cd ../functions
    npm install
    ```

### 4. Run Locally

The best way to run the application locally is to use the Firebase Emulator Suite, which provides local emulation for Authentication, Firestore, and Functions.

1.  **Start the Firebase Emulators:**
    From the root directory of the project, run:
    ```bash
    firebase emulators:start
    ```
    This will start the emulators and provide you with the ports for each service. The Emulator UI will also be available at `http://localhost:4000`, which is very useful for inspecting the local database and function logs.

2.  **Start the Frontend Development Server:**
    In a separate terminal, navigate to the `frontend` directory and run:
    ```bash
    cd frontend
    npm run dev
    ```
    The frontend application will now be running on `http://localhost:3000` and should be automatically configured to connect to the local Firebase Emulators.
